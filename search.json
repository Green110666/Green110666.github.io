[{"title":"123","date":"2023-10-05T05:11:21.000Z","url":"/2023/10/05/colorful/","categories":[["undefined",""]],"content":"​ 在使用Hexo搭建博客时会产生在markdown中引入图片在网页部署后无法显示的问题，即使将markdown文件中将图片的绝对路径改为相对路径也无济于事，因为在将博客上传后这些路径都会失效，除非直接将图片上传至github。 ​ 同时，图片的存放也存在问题，当博客数量增加后，图片的数量也会增加，如果不合理安排图片的存放路径会导致资源的杂乱无章。 ​ 为此，在此提出作者的解决方案。首先，在根目录下的’_config.yml’文件中找到’post_asset_folder’，并将 改为： ​ 其意义是在创建md文件时为此md文件创建一个同名文件夹，我们可以在此文件夹下保存我们博客中需要的图片。然后，为了使我们在markdown文件中可以用正确的语法插入图片，我们需要下载nodejs模块： ​ 然后我们就可以愉快地插入图片啦~ "},{"title":"关于公约数的思考（一）","date":"2023-01-14T08:31:40.000Z","url":"/2023/01/14/%E5%85%B3%E4%BA%8E%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"起因：leetcode1819. 序列中不同最大公约数的数目 给你一个由正整数组成的数组 nums 。 数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。 例如，序列 [4,6,16] 的最大公约数是 2 。 数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。 例如，[2,5,10] 是 [1,2,1,**2**,4,1,**5**,**10**] 的一个子序列。 计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。 关于这道题，我知道对于每个子序列依次去求他们的最大公约数十分繁琐，因此我先把主序列中的重复元素全部删除，只保留一个，然后先用unordered_set来存储每个单个元素，然后再去存储这个序列中两两配对之后所取得的公约数，我写的代码如下： 问题一在运行测试用例全部通过后我提交了，然而发现在通过大部分样例之后突然有一个样例失败了，而且输出的答案比预期的答案少一个。 然后我才意识到求三个数的最大公约数，这个公约数未必属于这三个数两两配对之后所得到的三个最大公约数所组成的集合，所以我最终输出的结果会有遗漏（刚好被我应付了绝大部分的测试样例），我起初并无法想明白为什么，直到我找到了一个反例： 例如三个数分别为：84、78、182（能被我找到这反例还真不容易），他们因式分解之后分别可以表示成3×2×2×7、3×2×13、2×13×7，从中不难看出两两配对之后的最大公约数分别为6、26、14，而最终三个数的最大公约数为2。进一步也可以看出满足三个数的最大公约数不属于这三个数两两配对之后所得到的三个最大公约数所组成的集合的前提是这三个数每个数在因式分解后都缺少一个或者多个另外两个数所共有的数，在上面那个反例中这三个所缺少的那个因数分别是13、7、3。最终这三个数的最大公约数小于任何两个数的最大公约数。 改进一为了能进一步解决上述的错误，我的想法是在得到最初那个unordered_set对象之后，由于其中都是得到了公约数的值，所以我打算将这些公约数再与序列进行求公约数的操作： 问题二这次我们提交之后没有上述的错误，然后问题出现在了运行时间上面，这次超时了。 换了一种解法，由于序列中的值不大同时，最大公约数的大小不可能大于序列中最大的值，所以根据枚举公约数来寻找答案，可同样超时。 改进二为了进行优化，所以必须从auto j:nums入手，这一步是为了找出序列中所有因数为i的数，找到这些数后，如果这些数的最大公约数是i，就说明i是最大公约数之一，如果一个个遍历会因为序列太大而耗时，所以使用vector&lt;bool&gt;对象，直接查找序列中是否存在i的倍数。最终通过的代码实现如下： "},{"title":"windows api笔记","date":"2023-01-06T10:52:15.000Z","url":"/2023/01/06/%E7%AC%94%E8%AE%B0/","tags":[["c/c++","/tags/c-c/"]],"categories":[["undefined",""]],"content":"动态库动态库是一种可以在程序运行时被加载的库文件。它是一种封装了一组功能的可执行文件，可以被多个应用程序共享和使用。 动态库的作用是让程序可以在运行时使用它所提供的功能。在编写程序时，可以通过调用动态库中的函数来使用它所提供的功能。动态库会在程序运行时加载到内存中，并为程序提供服务。这样，程序就可以在运行时使用动态库中的函数，而无需将这些函数编译到程序中。 动态库中包含了一组功能的函数，这些函数可以被程序调用。动态库还可以包含常量、变量和数据结构等内容。这些内容可以被程序使用，以实现更多的功能。 动态库的好处在于，它可以被多个应用程序共享和使用。这样，如果一个应用程序需要使用某个动态库的功能，可以直接调用这个动态库中的函数，而无需将这些函数编译到程序中。这样可以节省空间，提高程序的运行效率。 动态库常见的文件扩展名有.dll、.so和.dylib。.dll文件是Windows系统中的动态库文件，.so文件是Linux系统中的动态库文件，.dylib文件是MacOS系统中的动态库文件。 在Windows系统中，动态库文件通常以.dll为扩展名，例如GDI32.dll、Kernel32.dll等。这些动态库文件包含了Windows API的大部分函数，可以被多个应用程序共享和使用。 在Linux系统中，动态库文件通常以.so为扩展名，例如libc.so、libm.so等。这些动态库文件包含了Linux系统的核心函数和库函数，可以被多个应用程序共享和使用。 在MacOS系统中，动态库文件通常以.dylib为扩展名，例如libc.dylib、libm.dylib等。这些动态库文件包含了MacOS系统的核心函数和库函数，可以被多个应用程序共享和使用。 头文件与动态库的关系头文件是用来声明函数原型的文件，它是编写C&#x2F;C++程序时使用的文件。头文件中包含了函数的原型定义，这些原型定义告诉编译器函数的名称、返回类型、参数类型等信息。 动态库是一种可以在程序运行时被加载的库文件，它封装了一组功能的可执行文件。动态库中包含了函数的代码实现，这些代码可以被多个应用程序共享和使用。 头文件和动态库是相互独立的，但是它们之间也有一定的联系。在编写程序时，需要使用头文件来声明函数的原型定义，然后在程序中调用这些函数时，程序会去动态库中寻找这些函数的代码实现。在程序运行时，会先加载动态库，然后才能使用动态库中的函数。 头文件和动态库的关系可以理解为：头文件是函数的原型，动态库是函数的实现。程序在运行时会先加载动态库，然后才能使用头文件中声明的函数。 在Windows系统中，常见的动态库文件有GDI32.dll、Kernel32.dll等，这些动态库文件对应的头文件是windows.h。在Linux系统中，常见的动态库文件有libc.so、libm.so等，这些动态库文件对应的头文件是stdio.h、math.h等。在MacOS系统中，常见的动态库文件有libc.dylib、libm.dylib等，这些动态库文件对应的头文件是stdio.h、math.h等。 那在程序中调用windows.h头文件的时候并不会自动引入gdi32.dll，而是需要手动地去链接这个库吗？在Windows系统中，如果想在程序中使用windows.h头文件中声明的函数，就需要在编译时链接GDI32.dll动态库。这意味着，需要在编译命令中指定GDI32.lib这个库文件。例如，如果使用gcc编译器，可以使用命令“gcc main.c GDI32.lib”来编译程序。 在Windows系统中，可以通过两种方式来调用windows.h头文件中的函数： 使用动态链接库(DLL)。在这种情况下，你只需要在编译时链接GDI32.lib库文件，就可以在程序中使用windows.h头文件中声明的函数。 使用静态链接库(lib)。在这种情况下，你需要在编译时使用&#x2F;MT或&#x2F;MTd选项，表示使用静态链接库。这时，编译器会将windows.h头文件中声明的函数的代码实现直接编译到程序中，而无需链接GDI32.lib库文件。 所以可以通过pragma来链接这些库？在Windows系统中，可以使用pragma指令来链接动态库。pragma指令是C&#x2F;C++编译器的扩展指令，用来向编译器提供特定的信息和指示。 例如，可以使用如下的pragma指令来链接GDI32.dll动态库： 这条指令会告诉编译器，在编译本程序时，需要链接GDI32.lib库文件。 Mingw-W64编译Windows程序提示：undefined reference to &#96;__imp_GetStockObject’ 的解决方法 "},{"title":"RK算法与字符串哈希","date":"2022-12-27T05:56:27.000Z","url":"/2022/12/27/RK%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"RK算法RK算法全名Rabin-Karp算法，是由Rabin和Karp提出的字符串匹配算法，该算法的原理是将字符串匹配问题转化为整数比较问题，例如在我们比较’abcbc’与’abc’时，我们可以运用霍纳法则，以3为一个单位，将对应长度的字符串表示为一个十进制整数，当两个整数相等时，说明匹配成功。但实际使用时会产生许多问题，例如随着字符串的长度增加导致整数的大小溢出，同时转化的复杂度也会提升，为此可以采用取模的方法规避这一问题，但实际上取模的副作用就是产生一些错误匹配，也被称为伪命中点，即这些字符串转化为十进制整数后，虽然两个整数大小是不相等的，然而取模之后大小相等，结果就是也被认作是匹配的。 字符串哈希字符串哈希算法与RK算法类似，或者说是RK算法的拓展，也是把字符串映射到整数的方法，而在这个映射函数中我们不一定使用霍纳法则，这个函数也被称作Hash（哈希）函数。 性质具体来说，哈希函数最重要的性质可以概括为下面两条： 在 Hash 函数值不一样的时候，两个字符串一定不一样； 在 Hash 函数值一样的时候，两个字符串不一定一样（但有大概率一样，且我们当然希望它们总是一样的）。 Hash 函数值一样时原字符串却不一样的现象我们称为哈希碰撞。 解释在霍纳法则中我们使用的是以10为基数，但实际上我们可以自由选择这个基数，只要合适。对于取模的数m，我们最好选择素数。通过哈希函数f，我们得到的是一个字符串lenth-1阶的多项式，若文本串t和模式串s在x&#x3D;b的时候哈希碰撞，则b是f的一个根，即当x&#x3D;b时，哈希函数所对应的值是相等的，而为了使哈希函数所得到的值域尽可能大，这与m有关，显然当m是素数的时候是最优的，f的根最多有lenth-1个，而b是从0到m中均匀选取，则最终发生哈希碰撞的概率是(lenth-1)&#x2F;m，借助这个概率也可以帮助我们选择更优的基数与m。 最简单的实现 对于RK算法与字符串哈希而言，在时间复杂度上并不优于自动机与KMP算法之类，但是却给我们提供一种思路：映射。同时，字符串哈希同样可以进行不断的优化和调整，变得更加实用。"},{"title":"预处理器粘合剂：##运算符","date":"2022-12-27T05:16:46.000Z","url":"/2022/12/27/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E7%B2%98%E5%90%88%E5%89%82%EF%BC%9A-%E8%BF%90%E7%AE%97%E7%AC%A6/","tags":[["c/c++","/tags/c-c/"]],"categories":[["undefined",""]],"content":"在介绍##运算符之前，我们需要先了解一下#运算符，在我们的程序中经常会使用#define语句定义函数宏，例如： 在这行代码中#x的作用突显了出来，它可以指代函数宏中的’x’，倘若没有#x，而直接用： 导致的结果就是printf语句中的x表示的是一个字符，而不是参数x的指代。 与#运算符类似，##运算符可用于函数宏的替换部分，那##运算符为何被称作黏合剂？请参考如下代码： 在这行代码中，宏NAME(4)将展开为x4。 在更复杂的代码中，如： 在这行代码中，通过我们改变n来输出xn与xn的值的对应关系，通过对#和##运算符的运用为我们的代码提供了便利。"},{"title":"解决HEXO无法显示图片的方案","date":"2022-12-26T12:53:03.000Z","url":"/2022/12/26/test/","tags":[["blog","/tags/blog/"]],"categories":[["undefined",""]],"content":"​ 在使用Hexo搭建博客时会产生在markdown中引入图片在网页部署后无法显示的问题，即使将markdown文件中将图片的绝对路径改为相对路径也无济于事，因为在将博客上传后这些路径都会失效，除非直接将图片上传至github。 ​ 同时，图片的存放也存在问题，当博客数量增加后，图片的数量也会增加，如果不合理安排图片的存放路径会导致资源的杂乱无章。 ​ 为此，在此提出作者的解决方案。首先，在根目录下的’_config.yml’文件中找到’post_asset_folder’，并将 改为： ​ 其意义是在创建md文件时为此md文件创建一个同名文件夹，我们可以在此文件夹下保存我们博客中需要的图片。然后，为了使我们在markdown文件中可以用正确的语法插入图片，我们需要下载nodejs模块： ​ 然后我们就可以愉快地插入图片啦~ "}]